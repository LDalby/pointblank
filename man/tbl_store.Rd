% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tbl_store.R
\name{tbl_store}
\alias{tbl_store}
\title{Define a store of tables with table-prep formulas}
\usage{
tbl_store(..., .list = list2(...))
}
\arguments{
\item{...}{Expressions that contain table-prep formulas and table names for
data retrieval. Two-sided formulas (e.g, \verb{<LHS> ~ <RHS>}) are to be used,
where the left-hand side is a given name and the right-hand is the portion
that is is used to obtain the table.}

\item{.list}{Allows for the use of a list as an input alternative to \code{...}.}
}
\value{
A \code{tbl_store} object that contains table-prep formulas.
}
\description{
It can be useful to set up all the data sources you need and just draw from
them when necessary. This upfront configuration with \code{tbl_store()} can be
quite useful since we can define the methods for obtaining tabular data from
mixed sources (e.g., database tables, tables generated from flat files, etc.)
and provide names for these data pulling procedures as a way to access the
data with \code{\link[=tbl_get]{tbl_get()}}. Data preparation could be a part of what's in the
store (imagine procuring several mutated variations of the same source table
or pre-filtering a database table according to the system time). Another nice
aspect of organizing table-prep formulas in a single object is supplying
it to the \code{read_fn} argument of \code{\link[=create_agent]{create_agent()}} or \code{\link[=create_informant]{create_informant()}} via
\code{$} notation (e.g, \verb{create_agent(read_fn = <tbl_store>$<name>)}).
}
\section{Function ID}{

1-8
}

\examples{
# Define a `tbl_store` object by adding
# table-prep formulas inside the
# `tbl_store()` call
# tbls <- 
#   tbl_store(
#     small_table_duck ~ db_tbl(
#       table = small_table,
#       dbname = ":memory:",
#       dbtype = "duckdb"
#     ),
#     ~ db_tbl(
#       table = "rna",
#       dbname = "pfmegrnargs",
#       dbtype = "postgres",
#       host = "hh-pgsql-public.ebi.ac.uk",
#       port = 5432,
#       user = I("reader"),
#       password = I("NWDMCE5xdipIjRrp")
#     ),
#     all_revenue ~ db_tbl(
#       table = file_tbl(
#         file = from_github(
#           file = "all_revenue_large.rds",
#           repo = "rich-iannone/intendo",
#           subdir = "data-large"
#         )
#       ),
#       dbname = ":memory:",
#       dbtype = "duckdb"
#     ),
#     sml_table ~ pointblank::small_table
#   )

# Once this object is available, you can
# check that the table of interest is
# produced to your specification with the
# `tbl_get()` function
# tbl_get(
#   tbl = "small_table_duck",
#   store = tbls
# )

# Another simpler way to get the same
# table materialized is by using `$` to
# get the entry of choice for `tbl_get()`
# tbls$small_table_duck \%>\% tbl_get()

# Creating an agent is easy when all
# table-prep formulas are encapsulated
# in a `tbl_store` object; use `$` notation
# to pass the appropriate procedure for
# reading a table to the `read_fn` argument
# agent <-
#   create_agent(read_fn = tbls$small_table_duck)

}
\seealso{
Other Planning and Prep: 
\code{\link{action_levels}()},
\code{\link{create_agent}()},
\code{\link{create_informant}()},
\code{\link{db_tbl}()},
\code{\link{file_tbl}()},
\code{\link{scan_data}()},
\code{\link{tbl_get}()},
\code{\link{tbl_source}()},
\code{\link{validate_rmd}()}
}
\concept{Planning and Prep}
