---
title: "Advanced Information Management"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(pointblank)
```

In the [*Intro to Information Management*](../articles/INFO-I.html) article, we learned all about how to synthesize information on a table, giving us a useful report that can be published and widely shared. We used a **pointblank** *informant* with a set of information functions to generate *info text* and put that text into the appropriate report sections. We're going to take this a few steps further and look into some more functionality makes *info text* more dynamic and also include a finalizing step in this workflow that accounts for evolving data. 

# Getting Snippets of Useful Text With the `info_snippet()` Function

A great source of information about the table can be the table itself. Suppose you want to show some categorical values from a particular column. Maybe you'd like to display the range of values in an important numeric column. Perhaps show some KPI values that can be calculated using data in the table? This can all be done with the `info_snippet()` function. You give the snippet a name and you give it a function call. Let's do this for the `small_table` dataset available in **pointblank**. This is what that table looks like:

```{r paged.print=FALSE}
small_table
```

If you wanted the mean value of data in column `d` rounded to one decimal place, one such we could do it is with this expression:

```{r}
small_table %>% .$d %>% mean() %>% round(1)
```

Inside of an `info_snippet()` call, which is used after creating the *informant* object, the expression would look like this:

```{r eval=FALSE}
informant <- 
  create_informant(
    read_fn = ~ small_table,
    tbl_name = "small_table",
    label = "Example No. 2"
  ) %>%
  info_snippet(
    snippet_name = "mean_d",
    fn = ~ . %>% .$d %>% mean() %>% round(1)
  )
```

The `small_table` dataset is associated with the `informant` as the target table, so, it's represented as the leading `.` in the functional sequence given to `fn`. It's important to note that there's a leading `~`, making this expression a RHS formula (we don't want to execute anything here, at this time). Lastly, the snippet has been given the name `"mean_d"`. We know that this snippet will produce the value `2304.7` so what can we do with that? We should put that value into some *info text* and use the `snippet_name` as the key. It works similarly to how the **glue** package does text interpolation, and here's the continuation of the above example:

```{r eval=FALSE}
informant <- 
  informant %>%
  info_columns(
    columns = vars(d),
    info = "This column contains fairly large numbers (much larger than
    those numbers in column `a`. The mean value is {mean_d}, which is
    far greater than any number in that other column."
  )
```

Within the text, there's the use of curly braces and the name of the snippet. That's where the `2304.7` value will be inserted. This methodology for inserting the computed values of snippets can be performed wherever *info text* is provided (in either of the `info_tabular()`, `info_columns()`, and `info_section()` functions). Let's take a look at the report by printing the `informant` object

```{r eval=FALSE}
informant
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_7.png" width=80%></div>
<br>

Hmm. There is `"... {mean_d} ..."` text in the report that should have been replaced with the mean value of column `d`. What gives? Well, there's one finalizing step that needs to be done and should always be done to wrap up the *Information Management* workflow and that is the use of the `incorporate()` function. Let's write the whole thing again and finish it off with a call to `incorporate()`.

```{r eval=FALSE}
informant <- 
  create_informant(
    read_fn = ~ small_table,
    tbl_name = "small_table",
    label = "Example No. 2"
  ) %>%
  info_snippet(
    snippet_name = "mean_d",
    fn = ~ . %>% .$d %>% mean() %>% round(1)
  ) %>%
    info_columns(
    columns = vars(d),
    info = "This column contains fairly large numbers (much larger than
    those numbers in column `a`. The mean value is {mean_d}, which is
    far greater than any number in that other column."
  ) %>%
  incorporate()

informant
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_8.png" width=80%></div>
<br>

This time, sweet success. The value appears and the overall formatting looks great! This is a very useful thing, so long as we remember to use the `incorporate()` function to make it happen (more on that in the next section). 

# Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date

Tables can change with time. Whether that data source is a public dataset, an organization's data table, or a continually-updated Excel file (ðŸ˜±), we should be ready for change. In the previous example, we used the `incorporate()` function to finalize the report. Without it, our snippet didn't work. There are two major things that `incorporate()` does for you in the *Information Management* workflow.

1. Evaluation of text snippets in all `info_snippet()` calls, and, insertion of snippets in *info text* within `"{<snippet_name>}"`.

2. Updating of table row and column counts in the header of the report.

We really are incorporating aspects of the table into the report with `incorporate()` but might might also think of it as regenerating, refreshing, or renewing the table. It gives **pointblank** license to access the table the same way that `interrogate()` does in the [**VALID-I**]((../articles/VALID-I.html)) validation workflow. On the first use of `incorporate()`, all text snippets will be put in their places; subsequent uses of `incorporate()` will replace the appropriate text as necessary. Every use of `incorporate()` will update the row and column counts in the header.

Here's a short demo of the header changing, because it's pretty instructive. Let's use our `small_table` object as `target_table`. With `dim()` we can be totally sure of the table dimensions. 

```{r}
target_table <- small_table

dim(target_table)
```

Let's allow an informant to access the `target_table` through the `read_fn` argument. In this case, the expression is `~ target_table` (it simply gets the table from the global workspace). After using `incorporate()` and printing the `informant_tt` object, let's just examine the header.

```{r}
informant_tt <- 
  create_informant(
    read_fn = ~ target_table,
    tbl_name = "target_table",
    label = "Example No. 3"
  ) %>%
  incorporate()

informant_tt
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_9.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the header.</p>
<br>

The number of rows and columns reported in the header checks out: 13 rows and 8 columns.

Now, let's manually enlarge the `target_table` and print the new row and column counts.

```{r}
target_table <- 
  dplyr::bind_rows(small_table, small_table) %>%
  dplyr::mutate(g = a + c)

dim(target_table)
```

We've got our informant object, let's see how `incorporate()` keeps pace with the change.

```{r}
informant_tt %>% incorporate()
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_10.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the header.</p>
<br>

Great! Using `incorporate()` has accurately updated the reporting of row and column counts in the header. And it's also very much worth noting that the use of a `read_fn` is important here. Had `target_table` been given to the `tbl` argument of `create_informant()`, that table would be bound to the informant in its initial state (with 13 rows and 8 columns) and any updates to the table wouldn't be reflected in the reporting upon using `incorporate()`. The table-reading function is meant for obtaining the table each and every time the table is needed. 

In short, unless you have no uses of `info_snippet()` and the table isn't expected to change, it's recommended to use `incorporate()` as the final call in this workflow.
