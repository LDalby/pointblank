#' Read a YAML file to create a new agent with a validation plan
#'
#' With `agent_yaml_read()` we can read a **pointblank** YAML file that
#' describes a validation plan to be carried out by an *agent*. What is returned
#' is a new *agent* with that validation plan, ready to interrogate the target
#' table at will (using the table-reading function stored as `read_fn`). The
#' agent can be given more validation steps if needed before using
#' [interrogate()] or taking part in any other agent ops (e.g., writing to disk
#' with [agent_write()] or [agent_yaml_write()]).
#' 
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#' 
#' @export
agent_yaml_read <- function(path) {
  expr_from_agent_yaml(path = path, interrogate = FALSE) %>%
    rlang::parse_expr() %>%
    rlang::eval_tidy()
}

#' Read a YAML file to interrogate a target table immediately
#'
#' The `agent_yaml_interrogate()` function operates much like the
#' [agent_yaml_read()] function (reading a **pointblank** YAML file and
#' generating an *agent* with a validation plan in place). The key difference is
#' that this function takes things a step function and interrogates the target
#' table (defined by table-reading, `read_fn`, function that is required in the
#' YAML file). The additional invocation of [interrogate()] uses the default
#' options of that function. As with [agent_yaml_read()] the agent is returned
#' except, this time, it has intel from the interrogation.
#'
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#'
#' @export
agent_yaml_interrogate <- function(path) {
  expr_from_agent_yaml(path = path, interrogate = TRUE) %>%
    rlang::parse_expr() %>%
    rlang::eval_tidy()
}

#' Display *pointblank* expressions using a YAML file with a validation plan
#'
#' The `agent_yaml_show_exprs()` function follows the specifications of a
#' **pointblank** YAML file to generate and show the **pointblank** expressions
#' for generating the described validation plan. The expressions are shown in
#' the console, providing an opportunity to copy the statements and extend as
#' needed. A **pointblank** YAML file can itself be generated by using the
#' [agent_yaml_write()] function with a pre-existing *agent*, or, it can be
#' carefully written by hand.
#'
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#'
#' @export
agent_yaml_show_exprs <- function(path) {
  message(expr_from_agent_yaml(path = path, interrogate = FALSE))
}

expr_from_agent_yaml <- function(path,
                                 interrogate = FALSE) {
  
  y <- yaml::read_yaml(file = path)
  
  expr_str <- 
    glue::glue(
      "
      create_agent(
      read_fn = {y$read_fn},
      name = \"{y$name}\",
      actions = {make_action_levels_str(y$action_levels)},
      embed_report = {y$embed_report},
      reporting_lang = \"{y$reporting_lang}\"
      ) {make_validation_steps(y$steps)}"
    ) %>% as.character()
  
  if (interrogate) {
    expr_str <- paste0(expr_str, "%>%\ninterrogate()")
  }
  expr_str
}

make_action_levels_str <- function(al) {
  
  if (is.null(al)) {
    return("NULL")
  }
  
  top_args <- c()
  
  if (!is.null(al$warn_fraction) || !is.null(al$warn_count)) {
    top_args <- c(top_args, paste0("warn_at = ", c(al$warn_fraction, al$warn_count)))
  }
  if (!is.null(al$stop_fraction) || !is.null(al$stop_count)) {
    top_args <- c(top_args, paste0("stop_at = ", c(al$stop_fraction, al$stop_count)))
  }
  if (!is.null(al$notify_fraction) || !is.null(al$notify_count)) {
    top_args <- c(top_args, paste0("notify_at = ", c(al$notify_fraction, al$notify_count)))
  }

  fns_args <- c()
  
  if (!is.null(al$fns$warn)) {
    fns_args <- c(fns_args, paste0("warn = ", al$fns$warn))
  }
  if (!is.null(al$fns$stop)) {
    fns_args <- c(fns_args, paste0("stop = ", al$fns$stop))
  }
  if (!is.null(al$fns$notify)) {
    fns_args <- c(fns_args, paste0("notify = ", al$fns$notify))
  }
  
  if (length(fns_args) > 0) {
    fns_args <- paste0("fns = list(\n", fns_args, ")")
  }
  
  paste0(
    "action_levels(\n",
    paste(
      c(paste0(top_args, collapse = "\n,"), fns_args),
      collapse = ",\n"
    ),
    ")"
  )
}

make_validation_steps <- function(steps) {
  
  if (length(steps) == 0) return("")
  
  str_exprs <- 
    lapply(
      seq_along(steps),
      FUN = function(x) { 
        
        step_i <- steps[[x]]
        step_fn <- names(step_i)
        
        args <- 
          vapply(
            seq_along(step_i[[1]]),
            FUN.VALUE = character(1), 
            FUN = function(x) {
              
              arg_name <- names(step_i[[1]][x])
              val <- step_i[[1]][[x]]
              
              if (arg_name == "fns") {
                return(paste("  ", val, collapse = ",\n"))
              }
              
              # Return empty string if seeing default values
              if (arg_name == "active" && val) {
                return("")
              }
              if (arg_name == "preconditions" && is.null(val)) {
                return("")
              }
              if (arg_name == "na_pass" && !val) {
                return("")
              }
              if (arg_name == "inclusive" && all(val)) {
                return("")
              }
              
              if (is.null(val[1])) {
                
                val <- "NULL"
                
              } else if (!is.null(val[1]) && is.logical(val[1])) {
                
                val <- as.character(val)
                
              } else if (!is.null(val[1]) &&
                         is.character(val[1]) &&
                         !grepl("^vars\\(.*?\\)$", val[1]) &&
                         !(arg_name %in% c("preconditions", "expr", "schema"))) {
                
                val <- paste0("\"", val, "\"")
              }
              
              if (length(val) > 1) {
                val <- paste0("c(", paste(as.character(val), collapse = ", "), ")")
              } else {
                val <- as.character(val)
              }
              
              paste(" ", arg_name[1], "=", val[1])
            }
          )
        
        args <- args[args != ""]
        
        args %>% 
          paste(collapse = ",\n") %>%
          paste0("%>%\n", step_fn, "(\n", ., "\n)")
      }
    ) %>% 
    unlist() %>%
    paste(collapse = " ") %>%
    paste0(., " ")
  
  gsub("rows_distinct(\n  columns = NULL\n)", "rows_distinct()", str_exprs, fixed = TRUE)
}
