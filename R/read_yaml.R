#' Read a YAML file to create a new agent with a validation plan
#'
#' @description 
#' With `agent_yaml_read()` we can read a **pointblank** YAML file that
#' describes a validation plan to be carried out by an *agent* (typically
#' generated by the [agent_yaml_write()] function. What's returned is a new
#' *agent* with that validation plan, ready to interrogate the target table at
#' will (using the table-reading function stored as the `read_fn`). The agent
#' can be given more validation steps if needed before using [interrogate()] or
#' taking part in any other agent ops (e.g., writing to disk with outputs intact
#' via [agent_write()] or again to **pointblank** YAML with
#' [agent_yaml_write()]).
#'
#' To get a picture of how `agent_yaml_read()` is interpreting the validation
#' plan specified in the **pointblank** YAML, we can use the
#' [agent_yaml_show_exprs()] function. That function shows us (in the console)
#' the **pointblank** expressions for generating the described validation plan.
#' 
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#'   
#' @examples
#' # Let's go through the process of
#' # developing an agent with a validation
#' # plan (to be used for the data quality
#' # analysis of the `small_table` dataset),
#' # and then offloading that validation
#' # plan to a pointblank YAML file; this
#' # will be read in with `agent_yaml_read()`
#' 
#' # We ought to think about what's
#' # tolerable in terms of data quality so
#' # let's designate proportional failure
#' # thresholds to the `warn`, `stop`, and
#' # `notify` states using `action_levels()`
#' al <- 
#'   action_levels(
#'     warn_at = 0.10,
#'     stop_at = 0.25,
#'     notify_at = 0.35
#'   )
#' 
#' # Now create a pointblank `agent` object
#' # and give it the `al` object (which
#' # serves as a default for all validation
#' # steps which can be overridden); the
#' # data will be referenced in a `read_fn`
#' # (a requirement for writing to YAML)
#' agent <- 
#'   create_agent(
#'     read_fn = ~small_table,
#'     label = "example",
#'     actions = al
#'   )
#' 
#' # Then, as with any `agent` object, we
#' # can add steps to the validation plan by
#' # using as many validation functions as we
#' # want
#' agent <-
#'   agent %>% 
#'   col_exists(vars(date, date_time)) %>%
#'   col_vals_regex(
#'     vars(b), "[0-9]-[a-z]{3}-[0-9]{3}"
#'   ) %>%
#'   rows_distinct() %>%
#'   col_vals_gt(vars(d), 100) %>%
#'   col_vals_lte(vars(c), 5)
#'
#' # The agent can be written to a pointblank
#' # YAML file with `agent_yaml_write()`
#' # agent_yaml_write(agent, filename = "x.yml")
#' 
#' # The 'x.yml' file is available in the package
#' # through `system.file()`
#' yml_file <- 
#'   system.file("x.yml", package = "pointblank")
#' 
#' # We can view the YAML file in the console
#' # with the `agent_yaml_string()` function
#' agent_yaml_string(path = yml_file)
#' 
#' # The YAML can also be printed in the console
#' # by supplying the agent as the input
#' agent_yaml_string(agent = agent)
#' 
#' # At a later time, the YAML file can
#' # be read into a new agent with the
#' # `agent_yaml_read()` function
#' agent <- agent_yaml_read(path = yml_file)
#' 
#' class(agent)
#' 
#' # We can interrogate the data (which
#' # is accessible through the `read_fn`)
#' # with `interrogate()` and get an
#' # agent with intel, or, we can
#' # interrogate directly from the YAML
#' # file with `agent_yaml_interrogate()`
#' agent <- 
#'   agent_yaml_interrogate(path = yml_file)
#' 
#' class(agent)
#' 
#' @family pointblank YAML
#' @section Function ID:
#' 7-2
#' 
#' @export
agent_yaml_read <- function(path) {
  expr_from_agent_yaml(path = path, interrogate = FALSE) %>%
    rlang::parse_expr() %>%
    rlang::eval_tidy()
}

#' Read a YAML file to interrogate a target table immediately
#'
#' The `agent_yaml_interrogate()` function operates much like the
#' [agent_yaml_read()] function (reading a **pointblank** YAML file and
#' generating an *agent* with a validation plan in place). The key difference is
#' that this function takes things a step function and interrogates the target
#' table (defined by table-reading, `read_fn`, function that is required in the
#' YAML file). The additional auto-invocation of [interrogate()] uses the
#' default options of that function. As with [agent_yaml_read()] the agent is
#' returned except, this time, it has intel from the interrogation.
#'
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#'
#' @examples
#' # Let's go through the process of
#' # developing an agent with a validation
#' # plan (to be used for the data quality
#' # analysis of the `small_table` dataset),
#' # and then offloading that validation
#' # plan to a pointblank YAML file; this
#' # will later be read in as a new agent and
#' # the target data will be interrogated
#' # (one step) with `agent_yaml_interrogate()`
#' 
#' # We ought to think about what's
#' # tolerable in terms of data quality so
#' # let's designate proportional failure
#' # thresholds to the `warn`, `stop`, and
#' # `notify` states using `action_levels()`
#' al <- 
#'   action_levels(
#'     warn_at = 0.10,
#'     stop_at = 0.25,
#'     notify_at = 0.35
#'   )
#' 
#' # Now create a pointblank `agent` object
#' # and give it the `al` object (which
#' # serves as a default for all validation
#' # steps which can be overridden); the
#' # data will be referenced in a `read_fn`
#' # (a requirement for writing to YAML)
#' agent <- 
#'   create_agent(
#'     read_fn = ~small_table,
#'     label = "example",
#'     actions = al
#'   )
#' 
#' # Then, as with any `agent` object, we
#' # can add steps to the validation plan by
#' # using as many validation functions as we
#' # want
#' agent <-
#'   agent %>% 
#'   col_exists(vars(date, date_time)) %>%
#'   col_vals_regex(
#'     vars(b), "[0-9]-[a-z]{3}-[0-9]{3}"
#'   ) %>%
#'   rows_distinct() %>%
#'   col_vals_gt(vars(d), 100) %>%
#'   col_vals_lte(vars(c), 5)
#'
#' # The agent can be written to a pointblank
#' # YAML file with `agent_yaml_write()`
#' # agent_yaml_write(agent, filename = "x.yml")
#' 
#' # The 'x.yml' file is available in the package
#' # through `system.file()`
#' yml_file <- 
#'   system.file("x.yml", package = "pointblank")
#' 
#' # We can view the YAML file in the console
#' # with the `agent_yaml_string()` function
#' agent_yaml_string(path = yml_file)
#' 
#' # The YAML can also be printed in the console
#' # by supplying the agent as the input
#' agent_yaml_string(agent = agent)
#' 
#' # We can interrogate the data (which
#' # is accessible through the `read_fn`)
#' # through direct use of the YAML file
#' # with `agent_yaml_interrogate()`
#' agent <- 
#'   agent_yaml_interrogate(path = yml_file)
#' 
#' class(agent)
#'
#' # If it's desired to only create a new
#' # agent with the validation plan in place
#' # (stopping short of interrogating the data),
#' # then the `agent_yaml_read()` function
#' # will be useful
#' agent <- agent_yaml_read(path = yml_file)
#' 
#' class(agent)
#'
#' @family pointblank YAML
#' @section Function ID:
#' 7-3
#'
#' @export
agent_yaml_interrogate <- function(path) {
  expr_from_agent_yaml(path = path, interrogate = TRUE) %>%
    rlang::parse_expr() %>%
    rlang::eval_tidy()
}

#' Display *pointblank* expressions using a YAML file with a validation plan
#'
#' The `agent_yaml_show_exprs()` function follows the specifications of a
#' **pointblank** YAML file to generate and show the **pointblank** expressions
#' for generating the described validation plan. The expressions are shown in
#' the console, providing an opportunity to copy the statements and extend as
#' needed. A **pointblank** YAML file can itself be generated by using the
#' [agent_yaml_write()] function with a pre-existing *agent*, or, it can be
#' carefully written by hand.
#'
#' @param path A path to a YAML file that specifies a validation plan for an
#'   *agent*.
#' 
#' @examples 
#' # Let's create a validation plan for the
#' # data quality analysis of the `small_table`
#' # dataset; we need an agent and its
#' # table-reading function enables retrieval
#' # of the target table
#' agent <- 
#'   create_agent(
#'     read_fn = ~small_table,
#'     label = "example",
#'     actions = action_levels(
#'       warn_at = 0.10,
#'       stop_at = 0.25,
#'       notify_at = 0.35
#'     )
#'   ) %>%
#'   col_exists(vars(date, date_time)) %>%
#'   col_vals_regex(
#'     vars(b), "[0-9]-[a-z]{3}-[0-9]{3}"
#'   ) %>%
#'   rows_distinct() %>%
#'   col_vals_gt(vars(d), 100) %>%
#'   col_vals_lte(vars(c), 5)
#'
#' # The agent can be written to a pointblank
#' # YAML file with `agent_yaml_write()`
#' # agent_yaml_write(agent, filename = "x.yml")
#' 
#' # The 'x.yml' file is available in the package
#' # through `system.file()`
#' yml_file <- 
#'   system.file("x.yml", package = "pointblank")
#' 
#' # At a later time, the YAML file can
#' # be read into a new agent with the
#' # `agent_yaml_read()` function
#' agent <- agent_yaml_read(path = yml_file)
#' 
#' class(agent)
#' 
#' # To get a sense of which expressions are
#' # being used to generate the new agent, we
#' # can use `agent_yaml_show_exprs()`
#' agent_yaml_show_exprs(path = yml_file)
#'   
#' @family pointblank YAML
#' @section Function ID:
#' 7-5
#'
#' @export
agent_yaml_show_exprs <- function(path) {
  message(expr_from_agent_yaml(path = path, interrogate = FALSE))
}

expr_from_agent_yaml <- function(path,
                                 interrogate = FALSE) {

  # Read the YAML file with `yaml::read_yaml()`
  y <- yaml::read_yaml(file = path)
  
  # Get the `label` and `read_fn` fields from the YAML
  # file and create argument strings
  read_fn <- paste0("  read_fn = ", y$read_fn)
  label <- paste0("  label = \"", y$label, "\"")
  
  # Create argument strings for the `actions` and
  # `end_fns` arguments (which could be NULL)
  actions <- make_action_levels_str(y$actions)
  end_fns <- make_end_fns_str(y$end_fns)
  
  # The `embed_report` and `reporting_lang` values are
  # taken from the YAML (if they exist) and transformed
  # to argument strings
  if (!is.null(y$embed_report) && y$embed_report) {
    embed_report <- paste0("  embed_report = ", y$embed_report)
  } else {
    embed_report <- NULL
  }
  if (!is.null(y$reporting_lang) && y$reporting_lang != "en") {
    reporting_lang <- paste0("  reporting_lang = \"", y$reporting_lang, "\"")
  } else {
    reporting_lang <- NULL
  }
  
  # Generate all of the validation steps that make up
  # the agent's validation plan
  validation_steps <- make_validation_steps(y$steps)
  
  # Generate the expression string
  expr_str <-
    paste0(
      "create_agent(\n",
      paste(
        c(read_fn, label, actions, end_fns, embed_report, reporting_lang),
        collapse = ",\n"
      ),
      "\n) ",
      validation_steps
    )

  # Add the `interrogate()` statement if needed (this is
  # for the `agent_yaml_interrogate()` function)
  if (interrogate) {
    expr_str <- paste0(expr_str, "%>%\ninterrogate()")
  }
  
  expr_str
}

make_action_levels_str <- function(al) {
  
  if (is.null(al)) {
    return(NULL)
  }

  top_args <- c()
  
  if (!is.null(al$warn_fraction) || !is.null(al$warn_count)) {
    top_args <- c(top_args, paste0("warn_at = ", c(al$warn_fraction, al$warn_count)))
  }
  if (!is.null(al$stop_fraction) || !is.null(al$stop_count)) {
    top_args <- c(top_args, paste0("stop_at = ", c(al$stop_fraction, al$stop_count)))
  }
  if (!is.null(al$notify_fraction) || !is.null(al$notify_count)) {
    top_args <- c(top_args, paste0("notify_at = ", c(al$notify_fraction, al$notify_count)))
  }

  fns_args <- c()
  
  if (!is.null(al$fns$warn)) {
    fns_args <- c(fns_args, paste0("warn = ", al$fns$warn))
  }
  if (!is.null(al$fns$stop)) {
    fns_args <- c(fns_args, paste0("stop = ", al$fns$stop))
  }
  if (!is.null(al$fns$notify)) {
    fns_args <- c(fns_args, paste0("notify = ", al$fns$notify))
  }
  
  if (length(fns_args) > 0) {
    fns_args <- paste0("    fns = list(\n", paste0("      ", fns_args), "\n    )")
  }
  
  paste0(
    "  actions = action_levels(\n",
    paste0(
      c(paste0("    ", top_args, collapse = ",\n"), fns_args),
      collapse = ",\n"
    ),
    "\n  )"
  )
}

make_end_fns_str <- function(end_fns) {
  
  if (is.null(end_fns)) {
    return(NULL)
  }
  
  paste0(
    "  end_fns = list(\n",
      c(paste0("    ", end_fns, collapse = ",\n")),
    "\n  )"
  )
}

make_validation_steps <- function(steps) {
  
  if (length(steps) == 0) return("")
  
  str_exprs <- 
    lapply(
      seq_along(steps),
      FUN = function(x) { 
        
        step_i <- steps[[x]]
        step_fn <- names(step_i)
        
        args <- 
          vapply(
            seq_along(step_i[[1]]),
            FUN.VALUE = character(1), 
            FUN = function(x) {
              
              arg_name <- names(step_i[[1]][x])
              val <- step_i[[1]][[x]]
              
              if (arg_name == "fns") {
                return(paste("  ", val, collapse = ",\n"))
              }
              
              # Return empty string if seeing default values
              if (arg_name == "active" && val) {
                return("")
              }
              if (arg_name == "preconditions" && is.null(val)) {
                return("")
              }
              if (arg_name == "na_pass" && !val) {
                return("")
              }
              if (arg_name == "inclusive" && all(val)) {
                return("")
              }
              
              if (is.null(val[1])) {
                
                val <- "NULL"
                
              } else if (!is.null(val[1]) && is.logical(val[1])) {
                
                val <- as.character(val)
                
              } else if (!is.null(val[1]) && arg_name == "actions") {

                return(make_action_levels_str(val))
                
              } else if (!is.null(val[1]) && arg_name == "schema") {

                vals <- 
                  vapply(
                    val,
                    FUN.VALUE = character(1),
                    USE.NAMES = FALSE,
                    FUN = function(x) {
                      if (length(x) > 1) {
                        val <- paste0("c(", paste0(paste0("\"", as.character(x), "\""), collapse = ", "), ")")
                      } else {
                        val <- paste0("\"", as.character(x), "\"")
                      }
                      val
                    }
                  )

                val <- 
                  paste0("  schema = col_schema(\n",
                    paste("   ", names(val), "=", vals, collapse = ",\n"),
                    "\n  )"
                  )
                
                return(val)
                
              } else if (!is.null(val[1]) &&
                         is.character(val[1]) &&
                         !grepl("^vars\\(.*?\\)$", val[1]) &&
                         !(arg_name %in% c("preconditions", "expr", "schema"))) {
                
                val <- paste0("\"", val, "\"")
              }
              
              if (length(val) > 1) {
                val <- paste0("c(", paste(as.character(val), collapse = ", "), ")")
              } else {
                val <- as.character(val)
              }
              
              paste(" ", arg_name[1], "=", val[1])
            }
          )
        
        args <- args[args != ""]
        
        args %>% 
          paste(collapse = ",\n") %>%
          paste0("%>%\n", step_fn, "(\n", ., "\n)")
      }
    ) %>% 
    unlist() %>%
    paste(collapse = " ") %>%
    paste0(., " ")
  
  gsub("rows_distinct(\n  columns = NULL\n)", "rows_distinct()", str_exprs, fixed = TRUE)
}


#
# Pointblank Metadata YAML
#

meta_yaml_read <- function(path) {
  
  # Read the YAML file with `yaml::read_yaml()`
  y <- yaml::read_yaml(file = path)
    
  # If `table` is present, perform a few validations on that component
  if ("table" %in% names(y)) {
    
    # Validate that 2nd-level elements have unique names
    if (any(duplicated(names(y[["table"]])))) {
      stop("Duplicate column names provided in `table`.", call. = FALSE)
    }
    
    # Get component names of `table`
    table_names <- names(y[["table"]])
    
    # Validate that there are only character vectors inside `table`
    checks <- 
      lapply(
        table_names,
        FUN = function(x) {
          x_names <- names(y[["table"]][x])
          
          for (z in x_names) {
            if (is.list(y[["table"]][[z]])) {
              stop("All subcomponents inside of `table` should be a character vector.",
                   call. = FALSE)
            }
          }
        }
      )
  }
  
  # If `columns` is present, perform a few validations on that component
  if ("columns" %in% names(y)) {
    
    # Validate that 2nd-level elements have unique names
    if (any(duplicated(names(y[["columns"]])))) {
      stop("Duplicate column names provided in `columns`.", call. = FALSE)
    }
    
    # Get listed column names
    column_names <- names(y[["columns"]])
    
    # Validate that there is no more than only a single level below
    # the column names
    checks <- 
      lapply(
        column_names,
        FUN = function(x) {
          x_names <- names(y[["columns"]][x])
          
          for (z in x_names) {
            
            if (is.list(y[["columns"]][[z]])) {
              if (!all(unname(unlist(lapply(y[["columns"]][[z]], is.character))))) {
                stop("All components inside of `columns/", z, "` should either be text or text under a single heading.",
                     call. = FALSE)
              }
            }
          }
        }
      )
  }
  
  # If any other items are present, perform a few validations on those
  other_names <- base::setdiff(names(y), c("table", "columns"))
  
  if (length(other_names) > 0) {
    
    # Validate that there is no more than only a single level below
    # the column names
    checks <- 
      lapply(
        other_names,
        FUN = function(x) {

          if (is.list(y[[x]])) {
            
            if (any(unname(unlist(lapply(y[[x]], Negate(is.character)))))) {
              
              idx <- which(unname(unlist(lapply(y[[x]], Negate(is.character)))))
              
              stop("All components inside `",x, "/", names(y[[x]][idx]),
                   "` should be a character vector.",
                   call. = FALSE)
            }
            
          } else if (!is.list(y[[x]])) {
            if (!is.character(y[[x]])) {
              stop("The component inside `", x, "` should be a character vector.",
                   call. = FALSE)
            }
          }
        }
      )
  }
  
  y
}

meta_yaml_tbl <- function(path) {
  
  # nocov start
  
  time_start <- Sys.time()
  
  y <- meta_yaml_read(path = path)
  
  if ("label" %in% names(y)) {
    meta_label <- y[["label"]]
    y <- y[names(y) != "label"]
  } else {
    meta_label <- paste0("[", gsub(" ", "|", as.character(Sys.time())), "]")
  }
  meta_label <- create_metadata_label_html(meta_label = meta_label)
  
  y_names <- names(y)
  
  priority_items <- c("table",  "columns")
  names_ordered <- sort(base::intersect(y_names, priority_items), decreasing = TRUE)
  names_others <- base::setdiff(y_names, priority_items)
  y <- y[c(names_ordered, names_others)]

  # Create empty table  
  tbl <- dplyr::tibble(group = character(0), item = character(0))

  if ("table" %in% y_names) {
    
    section <- y[["table"]]
    section_names <- names(section)
    
    if ("name" %in% section_names ||
        "_type" %in% section_names ||
        "type" %in% section_names) {
      
      if ("type" %in% section_names || "_type" %in% section_names) {
        if ("_type" %in% section_names) tbl_src <- section[["_type"]]
        if ("type" %in% section_names) tbl_src <- section[["type"]]
      } else {
        tbl_src <- NA_character_
      }
      
      if ("name" %in% section_names) {
        tbl_name <- section[["name"]]
      } else {
        tbl_name <- NA_character_
      }

      table_type_html <-  
        create_table_type_html(
          tbl_src = tbl_src,
          tbl_name = tbl_name
        )
      
      # Remove `name`, `type`, and `_type` from `section_names`
      section_names <- section_names[!(section_names %in% c("name", "type", "_type"))]
    } else {
      table_type_html <- ""
    }
    
    meta_columns <- NULL
    if ("columns" %in% section_names) meta_columns <- as.numeric(section[["columns"]][1])
    if ("_columns" %in% section_names) meta_columns <- as.numeric(section[["_columns"]][1])
    meta_rows <- NULL
    if ("rows" %in% section_names) meta_rows <- as.numeric(section[["rows"]][1])
    if ("_rows" %in% section_names) meta_rows <- as.numeric(section[["_rows"]][1])
    
    section_names <- 
      section_names[!(section_names %in% c("columns", "_columns", "rows", "_rows"))]
    
    if (length(section_names) > 0) {
      
      for (s_name in section_names) {
        
        tbl <- 
          add_to_tbl(
            tbl = tbl,
            item = title_text_md(section[s_name], elements = "vertical"),
            group = "Table"
          )
      }
    }
  } else {
    table_type_html <- ""
  }
  
  if ("columns" %in% y_names) {
    
    section <- y[["columns"]]
    column_names <- names(section)
    
    if (length(column_names) > 0) {
      
      for (column in column_names) {
        
        col_meta <- section[[column]]
        
        if (inherits(col_meta, "character")) {

          list_item <- 
            list(
              a = paste0("<strong>INFO</strong> ", unlist(col_meta))
            )
          
          names(list_item) <- column
          
          tbl <- 
            add_to_tbl(
              tbl = tbl,
              item = title_text_md(
                item = list_item,
                elements = "vertical",
                title_code = TRUE
              ),
              group = "Columns"
            )
          
        } else {
 
          list_item <- 
            list(
              a = paste0(
                "<strong>",
                toupper(names(col_meta)),
                "</strong> ", unlist(col_meta)
              )
            )
          
          names(list_item) <- column
          
          tbl <- 
            add_to_tbl(
              tbl = tbl,
              item = title_text_md(
                item = list_item,
                elements = "vertical", 
                title_code = TRUE
              ),
              group = "Columns"
            )
        }
      }
    }
  }
  
  if (length(names_others) > 0) {

    for (o_name in names_others) {
      
      o_section <- y[[o_name]]
      section_names <- names(o_section)
      
      if (is.null(section_names) &&
          is.character(o_section) &&
          length(o_section) > 0) {
        
        list_item <- 
          list(
            a = paste0("- ", unlist(o_section))
          )
        
        names(list_item) <- o_name
        
        tbl <- 
          add_to_tbl(
            tbl = tbl,
            item = title_text_md(
              item = list_item,
              elements = "vertical",
              use_title = FALSE
            ),
            group = o_name
          )
      }
      
      for (section in section_names) {
    
        section_meta <- o_section[section]
        
        if (inherits(section_meta, "character")) {

          list_item <- 
            list(
              a = paste0("<strong>INFO</strong> ", unlist(section_meta))
            )
          
          names(list_item) <- column
          
          tbl <- 
            add_to_tbl(
              tbl = tbl,
              item = title_text_md(
                item = list_item,
                elements = "vertical",
                title_code = TRUE
              ),
              group = o_name
            )
          
        } else {
          
          tbl <- 
            add_to_tbl(
              tbl = tbl,
              item = title_text_md(
                item = section_meta,
                elements = "vertical",
                use_title = TRUE
              ),
              group = o_name
            )
        }
      }
    }
  }
  
  # Generate table dimensions HTML
  table_dims <- 
    make_table_dims_html(columns = meta_columns, rows = meta_rows)
  
  # Combine label, table type, and table dimensions into
  # a table subtitle <div>
  combined_subtitle <-
    htmltools::tagList(
      htmltools::HTML(meta_label),
      htmltools::tags$div(
        style = htmltools::css(
          height = "25px",
          `margin-top` = "10px"
        ),
        htmltools::HTML(paste0(table_type_html, table_dims))
      ) 
    ) %>% as.character()
  
  time_end <- Sys.time()
  
  # Generate table execution start/end time (and duration)
  # as a table source note
  table_time <- 
    create_table_time_html(
      time_start = time_start,
      time_end = time_end
    )
  
  # Generate a gt table
  gt::gt(
    tbl,
    groupname_col = "group",
    id = "metadata"
  ) %>%
    gt::tab_header(
      title = "Pointblank Metadata",
      subtitle = gt::md(combined_subtitle)
    ) %>%
    gt::tab_source_note(source_note = gt::md(table_time)) %>%
    gt::fmt_markdown(columns = gt::vars(item)) %>%
    gt::cols_width(gt::everything() ~ gt::px(876)) %>%
    gt::tab_options(
      column_labels.hidden = TRUE,
      table.font.size = gt::pct(110)
    ) %>%
    gt::tab_style(
      style = gt::cell_text(
        size = gt::px(24),
        align = "left",
        indent = gt::px(5)
      ),
      locations = gt::cells_title("title")
    ) %>%
    gt::tab_style(
      style = gt::cell_text(
        size = gt::px(12),
        align = "left",
        indent = gt::px(5)
      ),
      locations = gt::cells_title("subtitle")
    ) %>%
    gt::tab_style(
      style = list(
        gt::cell_text(
          color = "#666666",
          weight = "bold",
          transform = "uppercase" 
        ),
        gt::cell_fill(color = "#FCFCFC"),
        gt::cell_borders(
          sides = "bottom",
          color = "#EFEFEF",
          weight = 1
        )
      ),
      locations = gt::cells_row_groups(groups = TRUE)
    ) %>%
    gt::tab_style(
      style = list(
        gt::cell_text(
          color = "#666666",
          size = "smaller",
          indent = gt::px(5)
        ),
        gt::cell_borders(
          sides = "top",
          style = "solid",
          color = "#EFEFEF",
          weight = 1
        )
      ),
      locations = gt::cells_body(columns = gt::everything())
    ) %>%
    gt::opt_table_font(font = gt::google_font("IBM Plex Sans")) %>%
    gt::opt_css(
      css = "
          #metadata p {
            overflow: visible;
            margin-top: 2px;
            margin-left: 0;
            margin-right: 0;
            margin-bottom: 5px;
          }
          #metadata ul {
            list-style-type: square;
            padding-left: 25px;
          }
          #metadata li {
            text-indent: -1px;
          }
          #metadata code {
            font-family: 'IBM Plex Mono', monospace, courier;
            font-size: 13px;
          }
          #metadata .pb_date {
            text-decoration-style: solid;
            text-decoration-color: #9933CC;
            text-decoration-line: underline;
            text-underline-position: under;
            font-variant-numeric: tabular-nums;
            margin-right: 4px;
          }
          #metadata .gt_sourcenote {
            height: 35px;
            padding: 0
          }
          #metadata .pb_label {
            border: solid 1px gray;
            padding: 0px 3px 0px 3px;
            margin-left: 2px;
            margin-right: 2px;
          }
        "
    )
  
  # nocov end
}

add_to_tbl <- function(tbl, item, group) {
  dplyr::bind_rows(tbl, dplyr::tibble(group = group, item = item))
}

title_text_md <- function(item,
                          use_title = TRUE,
                          title_level = 4,
                          title_code = FALSE,
                          elements = "vertical") {
  
  title <- names(item)
  item <- unname(unlist(item))
  
  # Process item with text transformers
  for (i in seq_along(item)) {
    
    # Dates
    if (grepl("\\([1-2][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9]\\)", item[i])) {
      
      for (j in 1:10) {
        item[i] <- 
          gsub(
            "(.*)\\(([1-2][0-9][0-9][0-9]-[0-1][0-9]-[0-3][0-9])\\)(.*)",
            "\\1<span class=\"pb_date\">\\2</span>\\3",
            item[i]
          )
      }
    }
    
    # Labels
    if (grepl("\\([A-Z][A-Z_]{1,}[A-Z]\\)", item[i])) {

      for (j in 1:10) {
        item[i] <-
          gsub(
            "(.*)\\(([A-Z][A-Z_]{1,}[A-Z])\\)(.*)",
            "\\1<span class=\"pb_label\">\\2</span>\\3",
            item[i]
          )
      }
    }
  }

  if (elements == "vertical") {

    item <- paste(item, collapse = "\n\n")
    
    if (use_title) {
      
      if (!title_code) {
        title <- gsub("_", " ", toupper(title))
      }

      item <- 
        paste0(
          "<",
          ifelse(title_code, "code", "h"),
          ifelse(title_code, "", as.character(title_level)), " ",
          "style=\"margin-bottom:5px;",
          ifelse(
            title_code,
            paste0(
              "font-weight:bold;line-height:2em;",
              "border:solid 1px #499FFE;",
              "padding:2px 8px 3px 8px;background-color:#FAFAFA;"
            ),
            ""
          ),
          "\">",
          title, "</", ifelse(title_code, "code", "h"),
          ifelse(title_code, "", as.character(title_level)), ">\n\n",
          item
        )
    }
    
  } else if (elements == "horizontal") {

    item <- paste(item, collapse = " &mdash; ")
    
    if (use_title) {
      
      if (!title_code) {
        title <- gsub("_", " ", toupper(title))
      }
      
      item <- 
        paste0(
          "<span style=\"font-size:1.17em;font-weight:bold;\">",
          ifelse(title_code, "<code style=\"font-weight:bold;margin-bottom:2px;\">", ""),
          title,
          ifelse(title_code, "</code>", ""),
          "</span>&nbsp;&nbsp;",
          item
        )
    }
  }
  
  item
}

create_metadata_label_html <- function(meta_label) {
  
  htmltools::tags$span(
    meta_label,
    style = htmltools::css(
      `text-decoration-style` = "solid",
      `text-decoration-color` = "#ADD8E6",
      `text-decoration-line` = "underline",
      `text-underline-position` = "under",
      color = "#333333",
      `font-variant-numeric` = "tabular-nums",
      `padding-left` = "4px",
      `margin-right` = "5px",
      `padding-right` = "2px"
    )
  ) %>% as.character()
}

make_table_dims_html <- function(columns = NULL, rows = NULL) {
  
  if (is.null(columns) && is.null(rows)) {
    return("")
  }

  columns <- columns %||% "&mdash;"
  rows <- rows %||% "&mdash;"
  
  as.character(
    htmltools::tagList(
      htmltools::tags$span(
        "ROWS",
        style = htmltools::css(
          `background-color` = "#eecbff",
          color = "#333333",
          padding = "0.5em 0.5em",
          position = "inherit",
          `text-transform` = "uppercase",
          margin = "5px 0px 5px 5px",
          `font-weight` = "bold",
          border = paste0("solid 1px #eecbff"),
          padding = "2px 15px 2px 15px",
          `font-size` = "smaller"
        )
      ),
      htmltools::tags$span(
        htmltools::HTML(rows),
        style = htmltools::css(
          `background-color` = "none",
          color = "#333333",
          padding = "0.5em 0.5em",
          position = "inherit",
          margin = "5px 0px 5px -4px",
          `font-weight` = "bold",
          border = paste0("solid 1px #eecbff"),
          padding = "2px 15px 2px 15px",
          `font-size` = "smaller"
        )
      ),
      htmltools::tags$span(
        "COLUMNS",
        style = htmltools::css(
          `background-color` = "#ffd4e5",
          color = "#333333",
          padding = "0.5em 0.5em",
          position = "inherit",
          `text-transform` = "uppercase",
          margin = "5px 0px 5px 1px",
          `font-weight` = "bold",
          border = paste0("solid 1px #ffd4e5"),
          padding = "2px 15px 2px 15px",
          `font-size` = "smaller"
        )
      ),
      htmltools::tags$span(
        htmltools::HTML(columns),
        style = htmltools::css(
          `background-color` = "none",
          color = "#333333",
          padding = "0.5em 0.5em",
          position = "inherit",
          margin = "5px 0px 5px -4px",
          `font-weight` = "bold",
          border = paste0("solid 1px #ffd4e5"),
          padding = "2px 15px 2px 15px",
          `font-size` = "smaller"
        )
      )
    )
  )
}
